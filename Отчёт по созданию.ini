# Отчёт по созданию информационной системы «Заметки» с синхронизацией и GUI на Python

## 1. Цели проекта

Проект «Заметки» должен обладать следующими ключевыми свойствами:

1. **Хранение заметок** — каждая заметка должна содержать заголовок, текст и метаданные (ID, дата последнего изменения, версия).
2. **Синхронизация между устройствами** — возможность работать на нескольких устройствах с единым набором заметок.
3. **GUI для удобного взаимодействия** — простой интерфейс для просмотра, создания и редактирования заметок.
4. **Модульность и расширяемость** — код должен быть легко расширяемым, чтобы добавлять поиск, шифрование, интеграцию с облачными сервисами или веб-версию.
5. **Оффлайн-работа** — возможность создавать и редактировать заметки без постоянного соединения с интернетом, с последующей синхронизацией.

---

## 2. Хранение данных

### 2.1 Локальное хранение

* **Формат файла:** JSON.

* **Структура:**

  ```json
  {
    "notes": {
      "uuid1": {"title": "Заголовок", "body": "Текст", "last_modified": "2025-11-10T12:00:00Z", "version": 1},
      "uuid2": {...}
    },
    "meta": {"created": "2025-11-10T12:00:00Z"}
  }
  ```

* **Преимущества JSON:**

  * Читаемость для человека.
  * Легко сериализуется/десериализуется в Python.
  * Подходит для небольших наборов заметок (до нескольких тысяч заметок без проблем).

* **Папка хранения:** `~/.notes_app/` или аналогичная, чтобы хранить данные отдельно от облачной синхронизации.

### 2.2 Облачное хранение

Есть два подхода:

1. **Через смонтированную папку облачного сервиса** (Dropbox, Google Drive, OneDrive):

   * Просто работать с локальным файлом в синхронизируемой папке.
   * Плюсы: простая реализация, не требует API.
   * Минусы: нет контроля над версионированием, возможны конфликты при одновременном редактировании.

2. **Через API облачного сервиса**:

   * Использовать Dropbox SDK, Google Drive API или OneDrive API для загрузки/выгрузки файла.
   * Плюсы: доступ к истории версий, контроль синхронизации.
   * Минусы: сложнее реализовать (требуется OAuth, обработка ошибок сети).

**Рекомендация для MVP:** начать со смонтированной папки облака. Позже можно перейти на API для надежной синхронизации и версионирования.

---

## 3. Модель заметок и CRUD

### 3.1 Структура заметки

* Поля:

  * `id` — UUID заметки.
  * `title` — заголовок.
  * `body` — текст.
  * `last_modified` — ISO-время последнего изменения.
  * `version` — версия (увеличивается при изменении).

### 3.2 Класс Note

```python
class Note:
    def __init__(self, nid=None, title="", body="", last_modified=None):
        self.id = nid or str(uuid.uuid4())
        self.title = title
        self.body = body
        self.last_modified = last_modified or datetime.now(timezone.utc).isoformat()
```

### 3.3 Класс NoteStore

* CRUD-операции:

  * `add_note()`
  * `update_note()`
  * `delete_note()`
  * `load()` / `save()`
* Обеспечивает работу с локальным файлом JSON.
* Позже может включать функцию `sync()` для слияния с облаком.

---

## 4. Синхронизация

### 4.1 Основные подходы

1. **Last-Writer-Wins (LWW)**:

   * Сравниваем `last_modified`.
   * Более свежая версия заметки перезаписывает старую.
   * Простое решение, подходит для MVP.

2. **Конфликтные копии**:

   * Если обе версии были изменены одновременно (или временные метки очень близки):

     * Сохраняем обе версии как `conflict-<id>.json`.
     * Пользователь может вручную объединить или выбрать версию.
   * Позволяет избежать потери данных при одновременном редактировании на разных устройствах.

3. **CRDT или Vectors clocks**:

   * Более сложный, но безопасный метод для одновременного редактирования.
   * Рекомендуется для будущих версий при расширении функционала (многопользовательская работа в реальном времени).

### 4.2 Алгоритм слияния (MVP)

1. Загружаем локальный файл и файл из облака.
2. Для каждой заметки:

   * Если заметка есть только в одной копии — оставляем её.
   * Если есть в обеих:

     * `last_modified` больше → выбираем её.
     * Равные timestamps + разный текст → создаём конфликтную копию.
3. Записываем объединённый файл обратно и локально, и в облако.

---

## 5. GUI на PySide6

### 5.1 Почему PySide6

* Полноценный Qt для Python.
* Кроссплатформенный (Windows/Linux/macOS).
* Поддерживает ListView, TextEdit, кнопки, диалоги — всё что нужно для заметок.
* Простая интеграция с таймерами и сигналами/слотами.

### 5.2 Рекомендуемая структура GUI

* **QMainWindow**

  * Список заметок (`QListWidget`) слева.
  * Редактор заметки (`QTextEdit` + `QLineEdit`) справа.
  * Кнопки: «Создать», «Сохранить».
* **События**

  * При выборе заметки в списке — загружаем её содержимое в редактор.
  * При нажатии «Сохранить» — обновляем заметку и сохраняем в JSON.
  * Автосохранение: можно через таймер каждые N секунд.
  * Поддержка обновления списка после синхронизации.

---

## 6. Рекомендации по архитектуре

1. **Разделение модели и GUI**:

   * Модель (`Note`, `NoteStore`) должна быть независимой от GUI.
   * GUI вызывает методы модели (CRUD + sync), но не управляет файлами напрямую.

2. **Синхронизация как отдельный слой**:

   * Функция `sync()` может быть вызвана вручную или по таймеру.
   * Можно добавить индикатор состояния («синхронизировано» / «не синхронизировано»).

3. **Конфликты и версии**:

   * Для MVP: LWW + сохранение конфликтов.
   * Для продвинутой версии: CRDT или векторные часы.

4. **Будущие улучшения**:

   * Поиск и фильтры по тексту и заголовку.
   * Сортировка по дате изменения или алфавиту.
   * Шифрование заметок перед синхронизацией.
   * Синхронизация через API облачных сервисов для более надёжной работы.

---

## 7. Почему именно так

| Компонент         | Решение                       | Обоснование                                                       |
| ----------------- | ----------------------------- | ----------------------------------------------------------------- |
| Хранение          | JSON локально + файл в облаке | Легко реализовать, читаемо, подходит для MVP                      |
| Синхронизация     | LWW + конфликтные копии       | Простая логика, минимальная потеря данных                         |
| GUI               | PySide6                       | Кроссплатформенный, богатый функционал для настольного приложения |
| Модель заметок    | Note + NoteStore классы       | Отделяет данные от GUI, легко расширять                           |
| Структура проекта | main.py, gui.py, notes.py     | Модульность, легко поддерживать                                   |
| Будущие улучшения | CRDT, шифрование, API облака  | Для продвинутой синхронизации, безопасности и реального времени   |

---

## 8. Пошаговая стратегия реализации

1. **MVP локально**

   * Реализовать Note и NoteStore.
   * Сохранение и загрузка локального JSON.
   * GUI с созданием/редактированием/удалением заметок.

2. **Синхронизация через облачную папку**

   * Использовать LWW + конфликты.
   * Периодический таймер для автоматической синхронизации.

3. **Расширения**

   * Поиск, сортировка, фильтры.
   * Автосохранение заметки.
   * Облачный API (Dropbox/Drive) с авторизацией OAuth.
   * Шифрование заметок.
   * CRDT для реального времени и нескольких пользователей.

---

## 9. Заключение

* **Для MVP**: JSON + LWW + PySide6 GUI + облачная папка синхронизации.
* **Почему так**: быстро реализуется, минимальные зависимости, легко отлаживается, безопасно с точки зрения потери данных.
* **Дальнейший рост**: модульная архитектура Note/NoteStore позволяет внедрять сложные функции синхронизации, шифрования и UI без переработки всей системы.